How to...
=========

Use the ``linedraw.py`` library to vectorise images
---------------------------------------------------

The ``linedraw.py`` library converts bitmap images to vectors.

Installation
~~~~~~~~~~~~

Install:

* ``Pillow``
* ``numpy``
* ``opencv-python-headless``


Using key functions
~~~~~~~~~~~~~~~~~~~

Launch a Python shell, and import ``linedraw`` so you have the functions at your disposal::

    >>> from linedraw import *


Convert an image to lines using ``vectorise()``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the ``images`` directory, you'll find an image named ``daniele.jpg``. To vectorise it, run::

    >>> lines = vectorise("me.jpg")

This will generate two things:

* a list of ``lines``, each of which is a list of points
* an SVG file at ``images/daniele.jpg.svg``, which will give you an idea of the vectorised representation

See :ref:`vectorise` for more details.

``vectorise()`` is useful when you are experimenting with vectorisation values to determine the best parameters
for processing a particular image.


Convert an image to JSON using ``image_to_json()``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``image_to_json()`` processes the images as above with ``vectorise()`` (taking the same parameters), and saves the
information as a JSON file to be used by the plotter.

The output file will be saved in ``images`` with a ``.json`` extension.

To plot the file with the plotter (having :ref:`previously set up a plotter instance <get_started>`)::

    >>> bg.plot_file("<file_name>")


Visualise how the plotter will draw the lines using ``draw()``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``draw()`` takes a set of lines (as generated by ``vectorise()``) and uses the Python turtle graphics module to draw
them, sequentially. It's fairly slow - but faster than the actual plotter.


Improve the plotter calibration
-------------------------------

Each servo motor is different, so the BrachioGraph can be calibrated exactly for your servos.

For each servo, you need to obtain the pulse-widths corresponding to a range of angles.

If you are using `SG90 motors <http://www.towerpro.com.tw/product/sg90-analog/>`_ or similar:

* they have almost 180 degrees of rotation
* they operate on pulse-widths from about 500 microseconds to about 2600 microseconds
* the centre of their travel is around 1500 microseconds
* one degree of travel corresponds to about 10 microseconds' difference

This is what the default ``angles_to_pw_1`` and ``angles_to_pw_2`` methods assume when the BrachioGraph is initialised.

However, the correspondence between pulse-widths and angles is not actually linear, and 1500µS in practice will be unlikely to coincide with the arms' zero positions. So, you can supply some values to improve upon these assumptions.


Find the centre angle pulse-widths
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, the BrachioGraph is initialised with::

    servo_1_zero=1500  # shoulder motor centre pulse-width
    servo_2_zero=1500  # elbow motor centre pulse-width

Probably, at the nominal "zero" angles (-90 and 90 degrees respectively) the arms will probably not be quite at the
those angles. You can use ``bg.drive()`` to discover what pulse-widths correspond to the centre positions.

Controls:

* 0: ``exit``
* a: ``increase shoulder motor pulse-width 10µS``
* a: ``decrease shoulder motor pulse-width 10µS``
* A: ``increase shoulder motor pulse-width 1µS``
* S: ``decrease shoulder motor pulse-width 1µS``
* k: ``increase elbow motor pulse-width 10µS``
* l: ``decrease elbow motor pulse-width 10µS``
* K: ``increase elbow motor pulse-width 1µS``
* L: ``decrease elbow motor pulse-width 1µS``

Now you can initialise the BrachioGraph with the two zero-position values you have discovered, adding ``servo_1_zero``
and ``servo_2_zero`` to the ``bg = BrachioGraph`` instantiation, for example:

..  code-block:: python
    :emphasize-lines: 4

    bg = BrachioGraph(
        inner_arm=9, outer_arm=9,
        bounds=bounds=(-8, 3, 8, 15),
        servo_1_zero=1695, servo_2_zero=1480
    )

This will reduce some distortion.


.. _polyfit:

Create better angle-to-pulse-width functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Specifying a precise value for the motors so that they align with the x and y axes when initialised is a good start.
However, it still leaves us with the problem of the motors' non-linearity - which requires a non-linear function to
address.

If we obtain a number of angles and their corresponding pulse-widths for each servo, ``numpy.polyfit()`` can be used to
determine a polynomial non-linear function for each one.

These can be determined by testing, using ``bg.drive()``.

Servo motors' horns generally attach in positions with 18 degrees between each one, so a good way to do this is to mark
a reference point on paper, and align the arms with that, removing them and replacing at a different angle each time.
Or you could just use a protractor and measure from that.

Then, these values can be supplied in the definition, with ``servo_1_angle_pws`` and ``servo_2_angle_pws``,

The ``brachiograph.py`` file contains an example, a definition for the actual machine depicted in this documentation::

    # angles in degrees and corresponding pulse-widths for the two arm servos
    servo_1_angle_pws = [
        [-162, 2490],
        [-144, 2270],
        [-126, 2070],
        [-108, 1880],
        [ -90, 1680],
        [ -72, 1540],
        [ -54, 1360],
        [ -36, 1190],
        [ -18, 1020],
        [   0,  830],
        [  18,  610],
    ]

    servo_2_angle_pws = [
        [  0,  610],
        [ 18,  810],
        [ 36,  970],
        [ 54, 1140],
        [ 72, 1310],
        [ 90, 1460],
        [108, 1630],
        [126, 1790],
        [144, 1970],
        [180, 2360],
    ]


    bg = BrachioGraph(
        inner_arm=9.0,            # the lengths of the arms
        outer_arm=9.0,            # the lengths of the arms
        bounds=(-8, 3, 8, 15),
        # angles in degrees and corresponding pulse-widths for the two arm servos
        servo_1_angle_pws=servo_1_angle_pws
        servo_2_angle_pws=servo_2_angle_pws
        # pulse-widths for pen up/down
        pw_up=1700,
        pw_down=1300,
    )

This visibly helps reduce distortion when the machine is drawing.

It's tempting to try to find optimum mathematical solutions to improve the precision and accuracy of the plotter, but
in practice the imprecision of the motors themselves and the play in the mechanical system make this rather futile.


Visualise the relationship between pulse-widths and angles
----------------------------------------------------------

``jupyter lab pulse_widths.ipynb`` will help visualise the relationship between pulse-widths and angles, using the same ``numpy.polyfit()`` as used in the BrachioGraph:

.. image:: /images/pw-angles.png
   :alt: 'Pulse-widths to angles'
   :class: 'main-visual'


.. _visualise-area:

Visualise the plotting area
----------------------------

To see how different plotter geometries work in practice, plug them into ``turtle_draw.py``, and run ``python turtle_draw.py`` to see the effect. The grey lines represent possible pen positions; your ``bg.bounds`` value
must fit inside this area.

.. image:: /images/plotting-area.png
   :alt: 'Plotting area'
   :class: 'main-visual'
